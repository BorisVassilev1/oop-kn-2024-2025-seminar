# 3) RAII, 0/3/5 правило

## Жизнен цикъл на обект

В езика C++, всеки обект в програмата е 'жив' в определен период от изпълнението на програмата. Всеки тип има няколко конструктора и точно един деструктор - функции, които инициализират/унищожават обект от съответния тип. Жизнения цикъл на обект винаги започва с изпълняването на конструктор и завършва с изпълняването на деструктор. Всяка употреба на обект преди извикването на конструктора му или след изпълнението на деструктора му е 'Недефинирано Поведение' (nasal demons).

- В случая на стекови (статично заделени променливи), конструктор на типа трябва да бъде извикан при декларирането на променлива и деструкторът се извиква в края на блокът от код, в който е декларирана променливата, т.е.:
```cpp
int main() {

	int a = 3; 		// constructor 'a'
	{
		int b = 2;	// constructor 'b'

	} 				// destructor  'b'

}					// destructor  'a'
```

- Операторите `new` и `delete` извикват съответно конструктори и деструктори.
- Ако горните две не могат да гарантират коректни жизнени цикли на обектите, значи нещо в кода е сбъркано (поне в рамките на този курс)

## RAII
Resource Acquisition Is Initialization (RAII) е техника, използвана в C++, която сдвоява използването на произволен ресурс, който трябва да бъде заделен/инициализиран преди ползване, с жизнения цикъл на обект. Например такива ресурси са динамично заделена памет, връзка в мрежата, файл, връзка с база данни.

### 1)
Създайте шаблон на клас `Array`, описващ динамично заделен масив.
- В конструктора му да се подава цяло число - брой елементи в масива.
- Използвайте RAII за да освободите клиентът (който използва класа) от задължението да трие динамично заделената памет за масива.
- Имплементирайте методи за достъп и модификация на елемент от масива
- Можем ли да постигнем предното само с един метод?

## 0/3/5 правило

Разглеждаме следните три метода на клас:
1) копиращ конструктор
2) оператор = за присвояване на стойност
3) деструктор
По подразбиране компилаторът генерира имплементации като извиква съответните методи на ВСИЧКИ ЧЛЕН–ДАННИ (правило за 0).
Ако при имплементацията на клас е нужно да се имплементира (или се изтрие) някой от трите метода, то трябва да се имплементират(или изтрият) и трите (правило за 3). Например ако дефинираме деструктор, компилаторът няма да генерира другите две по подразбиране.
За 5 - в седмица 10; Игнорираме го за сега.

### 2)
Класът `Array` от задача 1 отговаря ли на 0/3/5 правилото? Ако не-какви проблеми създава това? Поправете ги.

*0/3/5 правилото е препоръчително, а не задължително по стандарт. Най-добре е да го ползвате като списък от неща, за които трябва да помислим за да подсигурим коректността на заделянето и освобождаването на ресурси в програмата ни.*
